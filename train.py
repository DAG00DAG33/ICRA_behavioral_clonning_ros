# -*- coding: utf-8 -*-
"""Copy of Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12UpFCbrf1SdJP3hXwBCRPzs865-XgATH
"""

import torch
import numpy as np

import torch.nn as nn
import torch.nn.functional as F

device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')

class DrivingDataloader(torch.utils.data.Dataset):
    """Face Landmarks dataset."""

    def __init__(self, root_dir):
        self.root_dir = root_dir

    def __len__(self):
        #return np.load(self.root_dir + 'len.npy')
        return 4000 * 4

    def __getitem__(self, idx):
        if idx < 4000:
            image = np.load('/home/data/testing2/' + 'X_' + str(idx) + '.npy').astype(np.float32).reshape(-1, 1)
            image = np.moveaxis(image, -1, 0)
            label = np.load('/home/data/testing2/' + 'Y_' + str(idx) + '.npy').astype(np.float32)
        elif idx < 8000:
            image = np.load('/home/data/testing3/' + 'X_' + str(idx - 4000) + '.npy').astype(np.float32).reshape(-1, 1)
            image = np.moveaxis(image, -1, 0)
            label = np.load('/home/data/testing3/' + 'Y_' + str(idx - 4000) + '.npy').astype(np.float32)
        elif idx < 12000:
            image = np.load('/home/data/testing4/' + 'X_' + str(idx - 8000) + '.npy').astype(np.float32).reshape(-1, 1)
            image = np.moveaxis(image, -1, 0)
            label = np.load('/home/data/testing4/' + 'Y_' + str(idx - 8000) + '.npy').astype(np.float32)
        elif idx < 16000:
            image = np.load('/home/data/testing5/' + 'X_' + str(idx - 12000) + '.npy').astype(np.float32).reshape(-1, 1)
            image = np.moveaxis(image, -1, 0)
            label = np.load('/home/data/testing5/' + 'Y_' + str(idx - 12000) + '.npy').astype(np.float32)

        return image, label     


class Net(nn.Module):
    def __init__(self):
        super(Net, self).__init__()
        self.pipe = nn.Sequential(
            #nn.Dropout(p=0.3),
            nn.Conv1d(1, 20, 150, stride = 4),
            nn.ReLU(),
            nn.Conv1d(20, 20, 50, stride = 4),
            nn.ReLU(),
            nn.Flatten(),
            #nn.Dropout(p=0.1),
            nn.Linear(920, 50),
            nn.ReLU(),
            nn.Linear(50, 20),
            nn.ReLU(),
            nn.Linear(20, 2),
            nn.Tanh(),
        )
    def forward(self, x):
        return self.pipe(x)

def train(model, trainloader, epochs):
    model.train()
    n=30
    #lossFunc = nn.CrossEntropyLoss()
    #lossFunc = nn.BCELoss()
    lossFunc = nn.MSELoss()
    optimizer = torch.optim.SGD(net.parameters(), lr=0.001, momentum=0.9)
    #optimizer = torch.optim.Adam(net.parameters(), lr=1e-4)
        
    for epoch in range(epochs):
      running_loss = 0.0
      for i, data in enumerate(trainloader, 0):
          # get the inputs
          images=data[0].double().to(device).float()
          labels=data[1].double().to(device).float()

          #labels = labels.to(device=device, dtype=torch.int64)
          optimizer.zero_grad()

          outputs = model(images)
          loss = lossFunc(outputs, labels)

          loss.backward()
          running_loss += loss.item()

          optimizer.step()

          if i % n == n-1: 
              print('[%d, %5d] loss: %.3f' %
                    (epoch + 1, (i + 1)*64, running_loss / 64*n))
              running_loss = 0.0

if __name__ == '__main__' :

    train_dataset = DrivingDataloader('/home/data/testing4/')
    train_dataloader = torch.utils.data.DataLoader(train_dataset, batch_size=64, shuffle=True)

    diter = iter(train_dataloader)

    images, labels = diter.next()

    images.shape

    net = Net().float().to(device)

    from torchsummary import summary
    summary(net, (1, 1080))


    train(net, train_dataloader, 40)

    scripted_net = torch.jit.script(net)
    torch.jit.save(scripted_net, '/home/models/model3.pt')
